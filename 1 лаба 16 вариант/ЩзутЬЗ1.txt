
/*
omp_set_nested(1);      разрешает вложенную параллельность 
omp_set_nested(0);      запрещает вложенную параллельность (по умолчанию)
omp_set_num_threads(2); разрешает использовать только 2 процесса в последуюзих областях
omp_set_dynamic(1);     разрешает динамическое распределение (автоматическое), запуститься максимум ветвей (16)
omp_set_dynamic(0);     запрещает динамическое распределение (автоматическое), будет запускаться количество ветвей оределенных пользователей, по умолчанию 1
omp_get_thread_num();   возвращает номер нити
omp_get_num_threads()	возвращает Всего нитей в области
omp_get_max_threads()   возвращает максимально допустимое число нитей для использования в следующей параллельной области
omp_get_num_procs       возвращает количество процессоров, доступных для использования программе пользователя на момент вызова(изменчиво)
omp_in_parallel()       возвращает 1 если она была вызвана из активной параллельной области программы, если 0 - то последовательная область
setlocale(0, "");
omp_get_wtime();		вернет значение времени в секундах
omp_get_wtick();		вернет точность таймера в секундах
#pragma omp parallel -- распаралллить Параллельная область
#pragma omp parallel reduction (+: count) -- локальная count для каждой ветки. Оператор + означате, что по завершению всей области будет соверешнно суммирование всех локальных count, поэтому по умолчанию count =0
					 reduction(оператор:список) – задаёт оператор и список общих пе-
					 ременных; для каждой переменной создаются локальные копии в каж-
					 дой нити; локальные копии инициализируются соответственно типу
					 оператора (для аддитивных операций – 0 или его аналоги, для мульти-
					 пликативных операций – 1 или её аналоги); над локальными копиями
					 переменных после выполнения всех операторов параллельной области
					 выполняется заданный оператор; оператор это: для языка Си – +, *, -,
					 &, |, ^, &&, ||, для языка Фортран – +, *, -, .and., .or., .eqv., .neqv.,
					 max, min, iand, ior, ieor; порядок выполнения операторов не опреде-
					 лён, поэтому результат может отличаться от запуска к запуску.
#pragma omp parallel num_threads(3) разрешает в этой области использовать 3 процесса
#pragma omp master   позволяет обеспечить печать только процессом-мастером
#pragma omp single   Одна нить будет выполнять данный фрагмент, а все остальные нити будут ожидать завершения её работы
#pragma omp single nowait  Одна нить будет выполнять данный фрагмент, а все остальные следующие действия, не дожидаясь ее завершения
#сложнаpragma omp single copyprivate(n) - после выпонения нити, новое значение n будет использоваться во всех нитях до и после в нашей области.
#pragma omp master выделяют участок кода, который будет выполнен только нитью-мастером. Синхронизации нет.
shared - общие переменные
private - локальные данные
shared - данные перед входом в область
private - порожденные в области
Исключение составляют
переменные, являющиеся счетчиками итераций в цикле, по очевидным при-
чинам
firstprivate - создается лок переменная, инициализация автоматическая - предыдущее значение, из общего потока
private		 - создается лок переменная, инициализация не происходит. 
#pragma omp for
				Итеративная переменная неявно
делается локальной при входе в цикл. После завершения цикла значение ите-
ративной переменной цикла не определено, если она не указана в опции
lastprivate.

*/
#include <omp.h>
#include <time.h>
#include <locale.h>
#include <iostream>
using namespace std;
constexpr auto N = 5, M =5;
/*int main(int argc, char* argv[])
{
	setlocale(0, "");
	unsigned int A[N], B[N], C[N];
	int i, n;
	for (i = 0; i < N; i++) { A[i] = 0; B[i] = rand() % 10; C[i] = rand() % 10; }
	cout <<"A:";
	for (i = 0; i < N; i++) { cout<< " " << A[i];}
	cout << endl;
	cout << "B:";
	for (i = 0; i < N; i++) { cout << " " << B[i]; }
	cout << endl;
	cout << "C:";
	for (i = 0; i < N; i++) { cout << " " << C[i]; }
	cout << endl;
#pragma omp parallel shared(A, B, C) private(i, n)
	{
		n = omp_get_thread_num();
#pragma omp for
		for (i = 0; i < N; i++)
		{
			A[i] = B[i] + C[i];
			printf("Нить %d сложила элемент B[%d] с элементом С[%d] и записала результат %u в элемент A[%d]\n", n, i, i, A[i], i);
		}
	}
	cout << "A:";
	for (i = 0; i < N; i++) { cout << " " << A[i]; }
}*/

/*
int main(int argc, char* argv[])
{
	setlocale(0, "");
	unsigned int A[N][M];
	for (int i = 0; i < N; i++) {
		for (int j = 0; j < M; j++) {
			A[i][j] = rand() % 100;
		}
	}
	cout << "A:";
	for (int i = 0; i < N; i++) {
		for (int j = 0; j < M; j++) {
			cout << " " << A[i][j];
		}
		cout << "\n  ";
	}
	cout << endl;
	int i, j,n,k;
#pragma omp parallel shared(A) private(i, n, j, k)
	{
		n = omp_get_thread_num();
		#pragma omp for
		for (j = 0; j < M; j++)
		{
			printf("Нить %d сортирует столбец %d\n", n, j);
			for (k = 0; k < N - 1; k++) {
				for (i = 0; i < N - 1 - k; i++) {
					if (A[i][j] < A[i + 1][j])
					{
						printf("\tНить %d сравнила элементы [%d][%d] и [%d][%d] и поменяла их местами\n", n, i, j, i + 1, j);
						unsigned int temp = A[i][j];
						A[i][j] = A[i + 1][j];
						A[i + 1][j] = temp;
					}
					else {
						printf("\t\tНить %d сравнивает элементы [%d][%d] и [%d][%d] и не поменяла их.\n", n, i, j, i + 1, j);
					}
				}
			}
		}
	}
	cout << "A:";
	for (int i = 0; i < N; i++) {
		for (int j = 0; j < M; j++) {
			cout << " " << A[i][j];
		}
		cout << "\n  ";
	}
	cout << endl;
}
*/
int main(int argc, char* argv[])
{
	setlocale(0, "");
	unsigned int A[N];
	for (int i = 0; i < N; i++) {
			A[i] = rand() % 100+5;
	}
	cout << "A:";
	for (int i = 0; i < N; i++) {
			cout << " " << A[i];
		cout << "\n  ";
	}
	cout << endl;
	int i,n,k;
	unsigned int min = 999999;
#pragma omp parallel shared(A,min) private(i, n, k)
	{
		n = omp_get_thread_num();
		#pragma omp for
		for (i = 0; i < N; i++)
		{
			printf("Нить %d смотрит элемент A[%d]= %d\n", n, i, A[i]);
			if (min > A[i]) {
				min = A[i];
				printf("\tНить %d записала новый минимум %d\n", n, min);

			}
		}
	}
	cout << "min = "<<min;

	cout << endl;
}