
/*
omp_set_nested(1);      разрешает вложенную параллельность 
omp_set_nested(0);      запрещает вложенную параллельность (по умолчанию)
omp_set_num_threads(2); разрешает использовать только 2 процесса в последуюзих областях
omp_set_dynamic(1);     разрешает динамическое распределение (автоматическое), запуститься максимум ветвей (16)
omp_set_dynamic(0);     запрещает динамическое распределение (автоматическое), будет запускаться количество ветвей оределенных пользователей, по умолчанию 1
omp_get_thread_num();   возвращает номер нити
omp_get_num_threads()	возвращает Всего нитей в области
omp_get_max_threads()   возвращает максимально допустимое число нитей для использования в следующей параллельной области
omp_get_num_procs       возвращает количество процессоров, доступных для использования программе пользователя на момент вызова(изменчиво)
omp_in_parallel()       возвращает 1 если она была вызвана из активной параллельной области программы, если 0 - то последовательная область
setlocale(0, "");
omp_get_wtime();		вернет значение времени в секундах
omp_get_wtick();		вернет точность таймера в секундах
#pragma omp parallel -- распаралллить Параллельная область
#pragma omp parallel reduction (+: count) -- локальная count для каждой ветки. Оператор + означате, что по завершению всей области будет соверешнно суммирование всех локальных count, поэтому по умолчанию count =0
					 reduction(оператор:список) – задаёт оператор и список общих пе-
					 ременных; для каждой переменной создаются локальные копии в каж-
					 дой нити; локальные копии инициализируются соответственно типу
					 оператора (для аддитивных операций – 0 или его аналоги, для мульти-
					 пликативных операций – 1 или её аналоги); над локальными копиями
					 переменных после выполнения всех операторов параллельной области
					 выполняется заданный оператор; оператор это: для языка Си – +, *, -,
					 &, |, ^, &&, ||, для языка Фортран – +, *, -, .and., .or., .eqv., .neqv.,
					 max, min, iand, ior, ieor; порядок выполнения операторов не опреде-
					 лён, поэтому результат может отличаться от запуска к запуску.
#pragma omp parallel num_threads(3) разрешает в этой области использовать 3 процесса
#pragma omp master   позволяет обеспечить печать только процессом-мастером
#pragma omp single   Одна нить будет выполнять данный фрагмент, а все остальные нити будут ожидать завершения её работы
#pragma omp single nowait  Одна нить будет выполнять данный фрагмент, а все остальные следующие действия, не дожидаясь ее завершения
#сложнаpragma omp single copyprivate(n) - после выпонения нити, новое значение n будет использоваться во всех нитях до и после в нашей области.
#pragma omp master выделяют участок кода, который будет выполнен только нитью-мастером. Синхронизации нет.
shared - общие переменные
private - локальные данные
shared - данные перед входом в область
private - порожденные в области
Исключение составляют
переменные, являющиеся счетчиками итераций в цикле, по очевидным при-
чинам
firstprivate - создается лок переменная, инициализация автоматическая - предыдущее значение, из общего потока
private		 - создается лок переменная, инициализация не происходит. 
#pragma omp for
				Итеративная переменная неявно
делается локальной при входе в цикл. После завершения цикла значение ите-
ративной переменной цикла не определено, если она не указана в опции
lastprivate.

*/